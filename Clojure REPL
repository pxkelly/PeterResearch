REPL Instructions

Code can be entered at the bottom and executed by pressing shift+enter.

Try it now by typing (+ 1 1) in the bottom section and pressing shift+enter.

Working in another Clojure file and sending forms to the REPL is the most efficient way to work. Use the following key bindings to send code to the REPL. See the settings for more keybindings.

ctrl-alt-, then b
Execute block. Finds the block of Clojure code your cursor is in and executes that.

ctrl-alt-, s
Executes the selection. Sends the selected text to the REPL.

You can disable this help text in the settings.
Atom Ink does not appear to be installed. Install it to get a better REPL experience.
Starting REPL with lein in C:\Users\theki\.atom\packages/proto-repl/proto-no-proj
Default Proto REPL Leiningen project started
nREPL server started on port 61119 on host 127.0.0.1 - nrepl://127.0.0.1:61119
Refreshing code...
:reloading (user)
Default Proto REPL Leiningen project started
Refresh complete
; Generates random programs (a single program)
(defn generateProgram
  [terminalSet functionalSet]
  (list (nth functionalSet 0)
        (nth terminalSet (rand-int (count terminalSet)))
        (nth terminalSet (rand-int (count terminalSet)))))

; Returns a positive number based on how far away the program
; was from the test case
(defn testFitness
  [program testCase]
  (Math/abs (- (eval (list program)) testCase)))

; Returns the program that is better (less overall fitness score)
(defn tournament
  [programList testCase]
  (if (> (testFitness (nth programList 0) testCase)
         (testFitness (nth programList 1) testCase))
    (nth sel 1)
    (nth sel 0)))

; Choose the parents from the program list to be put up in the tournament
(defn chooseSelection
  [programList]
  (def sel (list (nth programList (rand-int (count programList)))))
  (def nextChoice (remove #{sel} programList))
  (conj sel (nth nextChoice (rand-int (count nextChoice)))))

; This will run the whole program
(defn main
  [testCase]
  (def programList (list (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])))
  (tournament (chooseSelection programList) testCase))
CompilerException java.lang.RuntimeException: Unable to resolve symbol: sel in this context, compiling:(C:\Users\theki\Desktop\PeterResearch\testgp.clj:19:5) 
(main 2)
CompilerException java.lang.RuntimeException: Unable to resolve symbol: main in this context, compiling:(C:\Users\theki\Desktop\PeterResearch\testgp.clj:1:1) 
(defn main
  [testCase]
  (def programList (list (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])))
  (tournament (chooseSelection programList) testCase))
CompilerException java.lang.RuntimeException: Unable to resolve symbol: chooseSelection in this context, compiling:(C:\Users\theki\Desktop\PeterResearch\testgp.clj:38:15) 
(defn chooseSelection
  [programList]
  (def sel (list (nth programList (rand-int (count programList)))))
  (def nextChoice (remove #{sel} programList))
  (conj sel (nth nextChoice (rand-int (count nextChoice)))))
user=>
#'user/chooseSelection
(defn tournament
  [programList testCase]
  (if (> (testFitness (nth programList 0) testCase)
         (testFitness (nth programList 1) testCase))
    (nth sel 1)
    (nth sel 0)))
user=>
#'user/tournament
(defn testFitness
  [program testCase]
  (Math/abs (- (eval (list program)) testCase)))
user=>
#'user/testFitness
(defn generateProgram
  [terminalSet functionalSet]
  (list (nth functionalSet 0)
        (nth terminalSet (rand-int (count terminalSet)))
        (nth terminalSet (rand-int (count terminalSet)))))
user=>
#'user/generateProgram
(main 2)
IllegalStateException Attempting to call unbound fn: #'user/main  clojure.lang.Var$Unbound.throwArity (Var.java:43)
(defn main
  [testCase]
  (def programList (list (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])))
  (tournament (chooseSelection programList) testCase))
user=>
#'user/main


user=>
nil
(main 2)
ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/eval10711 (form-init2561203239336484013.clj:1)
(defn testFitness
  [program testCase]
  (Math/abs (- (eval program) testCase)))
user=>
#'user/testFitness
(main 2)
user=>
(+ 3 8)
(main 2)

user=>
(+ 1 1)
(main 2)

user=>
(+ 8 8)
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

user=>
(+ 1 8)
(main 2)

user=>
(+ 3 1)
(main 2)

user=>
(+ 2 8)
(main 2)

user=>
(+ 2 1)
(defn main
  [testCase]
  (def programList (list (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])))
  (def parents (tournament (chooseSelection programList) testCase))
  (conj parents (tournament (chooseSelection programList) testCase))
  parents)
WARNING: parents already refers to: #'clojure.core/parents in namespace: user, being replaced by: #'user/parents
user=>
#'user/main
(main 2)

user=>
(+ 3 8)
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

user=>
(+ 7 3)
(main 2)

user=>
(+ 1 8)
(main 2)

user=>
(+ 8 3)
(defn main
  [testCase]
  (def programList (list (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])))
  (def parents (tournament (chooseSelection programList) testCase))
  (conj parents (tournament (chooseSelection programList) testCase)))
user=>
#'user/main
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
user=>
nil
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

user=>
((+ 1 8) + 8 1)
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(main 2)

user=>
((+ 2 7) + 3 7)
(defn main
  [testCase]
  (def programList (list (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])))
  (def parents (list (tournament (chooseSelection programList) testCase)))
  (conj parents (tournament (chooseSelection programList) testCase)))
user=>
#'user/main
(main 2)

user=>
((+ 3 8) (+ 3 7))
(main 2)

IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
(defn main
  [testCase]
  (def programList (list (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])))
  (chooseSelection programList))
user=>
#'user/main
(main 2)

user=>
((+ 1 8) (+ 8 2))
(main 2)

user=>
((+ 1 1) (+ 2 8))
(main 2)

user=>
((+ 2 8) (+ 1 1))
(main 2)

user=>
((+ 8 2) (+ 8 7))
(main 2)

user=>
((+ 7 2) (+ 7 7))
(main 2)

user=>
((+ 2 2) (+ 8 1))
(main 2)

user=>
((+ 7 3) (+ 2 8))
(main 2)

user=>
((+ 2 2) (+ 3 8))
(main 2)

user=>
((+ 2 8) (+ 1 7))
(main 2)

user=>
((+ 8 1) (+ 3 3))
(main 2)

user=>
((+ 7 7) (+ 8 2))
(main 2)

user=>
((+ 8 2) (+ 7 2))
(main 2)

user=>
((+ 1 1) (+ 3 2))
(main 2)

user=>
((+ 1 3) (+ 8 2))
(main 2)

user=>
((+ 3 1) (+ 3 1))
(main 2)

user=>
((+ 1 7) (+ 2 1))
(main 2)

user=>
((+ 7 2) (+ 2 8))
(defn main
  [testCase]
  (def programList (list (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])
                         (generateProgram [3 1 8 2 7] ['+])))
  (def parents (list (tournament (chooseSelection programList) testCase))))
user=>
#'user/main
(main 2)

user=>
#'user/parents
(main 2)


user=>
#'user/parents
(main 2)


IndexOutOfBoundsException   clojure.lang.RT.nthFrom (RT.java:885)
--------------------
